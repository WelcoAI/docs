# Common Workflow Patterns

This guide covers the most frequently used workflow patterns across different industries and business scenarios. These templates provide starting points for building your own sophisticated AI receptionist workflows.

## Business Categories and Use Cases

Welco AI provides pre-built templates across four main categories:

### Healthcare
- Patient appointment scheduling
- Symptom screening and triage
- Insurance verification
- Prescription refill requests
- Emergency escalation protocols

### Real Estate
- Property inquiry qualification
- Showing appointment booking
- Lead scoring and routing
- Market analysis requests
- Mortgage pre-qualification

### Customer Service
- Support ticket creation
- Issue troubleshooting
- Refund and return processing
- Account management
- Escalation to human agents

### General Business
- General inquiries and FAQ
- Contact information collection
- Service requests
- Callback scheduling
- Information gathering

## Essential Workflow Patterns

### 1. Greeting and Qualification Pattern

**Use Case**: Initial caller interaction with lead qualification

**Flow Structure**:
```
Scenario → Conversation (Greeting) → Logic Split (Qualification) → [Multiple Paths]
```

**Key Components**:
- **Scenario Node**: "When customers call for information about our services"
- **Conversation Node**: Warm greeting with qualification questions
- **Logic Split Node**: Routes based on caller responses (existing customer, new prospect, urgent issue)
- **Multiple Paths**: Different conversation flows for each caller type

**Best Practices**:
- Keep greeting warm but brief (under 30 seconds)
- Ask one qualifying question per conversation node
- Use logic splits to route rather than long conversation branches
- Always have a fallback path for unexpected responses

### 2. Appointment Scheduling Pattern

**Use Case**: Booking appointments with availability checking

**Flow Structure**:
```
Scenario → Conversation (Service Interest) → Function (Check Availability) → Logic Split → Conversation (Confirmation) → End Call
```

**Key Components**:
- **Function Node**: Integrates with calendar system (Cal.com, Google Calendar)
- **Extract Variables Node**: Captures preferred dates, times, contact information
- **Logic Split Node**: Handles available vs unavailable time slots
- **SMS Node**: Sends confirmation and reminder messages

**Implementation Details**:
- Use extract variables to capture structured appointment data
- Implement fallback times when first choice isn't available
- Always confirm appointment details before booking
- Send immediate SMS confirmation with calendar links

### 3. Support Ticket Creation Pattern

**Use Case**: Creating support tickets with proper categorization

**Flow Structure**:
```
Scenario → Conversation (Issue Description) → Extract Variables → Function (Create Ticket) → Conversation (Ticket Number) → End Call
```

**Key Components**:
- **Conversation Nodes**: Gather issue details naturally through conversation
- **Extract Variables Node**: Structure issue data (category, priority, description)
- **Function Node**: Creates ticket in support system (Zendesk, ServiceNow, etc.)
- **Logic Split Node**: Routes urgent issues to immediate transfer

**Best Practices**:
- Categorize issues early to route appropriately
- Extract contact information for follow-up
- Provide ticket numbers for reference
- Set proper expectations for response times

### 4. Lead Qualification and Routing Pattern

**Use Case**: Qualifying and routing sales leads

**Flow Structure**:
```
Scenario → Conversation (Needs Assessment) → Extract Variables → Logic Split (Qualification Score) → [Transfer to Sales/Schedule Callback/Information Packet]
```

**Key Components**:
- **Multiple Conversation Nodes**: Progressive qualification questions
- **Extract Variables Nodes**: Capture budget, timeline, decision-makers
- **Logic Split Nodes**: Score leads based on qualification criteria
- **Transfer Call Nodes**: Route qualified leads to appropriate sales reps
- **Function Nodes**: Update CRM with lead information

**Qualification Criteria Examples**:
- Budget range and authority to purchase
- Timeline for decision-making
- Specific needs and pain points
- Company size and industry

### 5. Information Gathering and Follow-up Pattern

**Use Case**: Collecting detailed information with multi-modal follow-up

**Flow Structure**:
```
Scenario → Intake Form → Extract Variables → Function (Store Data) → SMS (Follow-up) → End Call
```

**Key Components**:
- **Intake Form Node**: Structured data collection
- **Extract Variables Node**: Organize collected information
- **Function Node**: Store in CRM or database
- **SMS Node**: Send follow-up information or next steps

**Use Cases**:
- Insurance claims initiation
- Service request details
- Event planning information
- Consultation preparation

## Industry-Specific Patterns

### Healthcare Appointment Booking

**Scenario**: "When patients call to schedule appointments"

**Typical Flow**:
1. **Greeting Conversation**: Warm welcome and reason for call
2. **Extract Variables**: Patient name, DOB, insurance information
3. **Function Node**: Verify patient in system and insurance eligibility
4. **Logic Split**: New patient vs existing patient paths
5. **Conversation**: Available appointment types and preferences
6. **Function Node**: Check doctor availability
7. **Conversation**: Offer available slots
8. **Extract Variables**: Confirm appointment details
9. **Function Node**: Book appointment in EMR system
10. **SMS Node**: Send confirmation with pre-visit instructions

**Special Considerations**:
- HIPAA compliance for patient information
- Insurance verification before booking
- Different flows for urgent vs routine appointments
- Integration with EMR systems

### Real Estate Lead Qualification

**Scenario**: "When prospects call about properties or services"

**Typical Flow**:
1. **Greeting Conversation**: Welcome and identify interest area
2. **Logic Split**: Buying vs selling vs renting
3. **Conversation**: Qualification questions (budget, timeline, location)
4. **Extract Variables**: Contact info and preferences
5. **Function Node**: Search MLS for matching properties
6. **Logic Split**: Properties available vs no matches
7. **Conversation**: Present options or schedule consultation
8. **Transfer Call**: Route to appropriate agent
9. **SMS Node**: Send property links or consultation confirmation

**Key Variables to Extract**:
- Price range and financing pre-approval status
- Preferred neighborhoods or areas
- Timeline for purchase/sale
- Current housing situation
- Contact preferences

### E-commerce Customer Service

**Scenario**: "When customers call about orders, returns, or issues"

**Typical Flow**:
1. **Greeting Conversation**: Welcome and reason for call
2. **Logic Split**: Order inquiry vs return vs general question
3. **Extract Variables**: Order number or customer email
4. **Function Node**: Lookup order in system
5. **Logic Split**: Order found vs not found
6. **Conversation**: Present order details and resolution options
7. **Function Node**: Process return, refund, or update
8. **Conversation**: Confirm resolution and next steps
9. **SMS Node**: Send confirmation or tracking information

## Advanced Pattern Combinations

### Multi-Modal Engagement Pattern

Combines voice, SMS, and email for comprehensive customer engagement:

1. **Initial Voice Conversation**: Capture basic information and preferences
2. **SMS Follow-up**: Send links to forms or additional resources
3. **Function Integration**: Update CRM with engagement history
4. **Conditional Logic**: Different follow-up based on engagement level
5. **Automated Scheduling**: Book follow-up calls or meetings

### Escalation and Fallback Pattern

Ensures human oversight for complex or sensitive situations:

1. **Standard Workflow**: Normal conversation flow
2. **Logic Splits**: Detect escalation triggers (frustrated customer, complex issue, high-value prospect)
3. **Conditional Transfers**: Route to appropriate human agents
4. **Fallback Conversations**: Handle system failures gracefully
5. **Logging and Alerts**: Notify managers of escalations

## Pattern Selection Guidelines

### Simple Information Requests
- Use basic conversation → end call pattern
- No complex logic or integrations needed
- Examples: hours, location, basic pricing

### Transactional Processes
- Use conversation → extract variables → function → confirmation pattern
- Include error handling and confirmation steps
- Examples: booking, ordering, account updates

### Complex Sales Processes
- Use multi-stage qualification → logic routing → transfer pattern
- Include lead scoring and CRM integration
- Examples: real estate, B2B sales, high-ticket services

### Support and Service
- Use triage → categorization → resolution or escalation pattern
- Include ticket creation and follow-up automation
- Examples: technical support, customer service, warranty claims

<Warning>
**Important**: Always include fallback paths for unexpected responses or system failures. Every logic split should have an "else" condition that handles unmatched scenarios gracefully.
</Warning>

## Testing Your Patterns

### Validation Checklist

- **Happy Path**: Does the ideal scenario work smoothly?
- **Edge Cases**: How does it handle unexpected responses?
- **Error Conditions**: What happens when external systems fail?
- **Variable Validation**: Are required fields properly collected?
- **Integration Points**: Do external API calls work reliably?

### Performance Considerations

- **Response Time**: Keep function calls under 3 seconds when possible
- **Conversation Flow**: Limit conversation nodes to 2-3 exchanges before action
- **Error Recovery**: Implement automatic retries with exponential backoff
- **Fallback Options**: Always provide human agent transfer option

## Next Steps

Once you've identified the right pattern for your use case:

1. **Start with Template**: Use the closest pre-built template from your category
2. **Customize Nodes**: Modify conversation content and logic for your business
3. **Configure Integrations**: Set up function nodes with your systems
4. **Test Thoroughly**: Validate all paths and edge cases
5. **Monitor and Improve**: Use execution logs to optimize performance

For detailed implementation guidance, explore the specific node type documentation and integration guides in the following sections.